<html>

  <head>
    <style>
      body{ margin: 0px; }
    </style>
  </head>

  <body>

    <script src="lib/three.min.js">             </script>
    <script src="lib/jquery.min.js">            </script>
    <script src="lib/TrackballControls.js">     </script>
    <script src="lib/stats.min.js">             </script>
    
    <script src="lib/ShaderLoader.js"></script>

    <script>



      var matcap = THREE.ImageUtils.loadTexture('img/rough-aluminium.jpg');

      var uniforms = {

        t_matcap:{ type:"t" , value: matcap },
        stepDepth:{ type:"f" , value: .03 },
        lightPos:{ type:"v3" , value: new THREE.Vector3( 2 , 0 , 0 ) },
        iModelMat:{ type:"m4" , value: new THREE.Matrix4() }

      }

      var meshes = [];
      var camera, renderer, scene , controls;
      
      var vs, fs;

      var geometry, material , light;

      var stats;

      var shaders = new ShaderLoader( 'shaders' );

      shaders.shaderSetLoaded = function(){
        init();
        animate();
      }

      shaders.load( 'vs-bifrost' , 'bifrost' , 'vertex' );
      shaders.load( 'fs-bifrost' , 'bifrost' , 'fragment' );

      function init(){

        var w = window.innerWidth;
        var h = window.innerHeight;

        camera = new THREE.PerspectiveCamera( 65 , w/h , .1 , 100 );
        camera.position.z = 2;

        controls = new THREE.TrackballControls( camera );
        scene = new THREE.Scene();

        geometry = new THREE.PlaneGeometry( 10, 10 );
       // geometry = new THREE.BoxGeometry( 1, 1,1 );
        //geometry = new THREE.IcosahedronGeometry( 1,4 );
       // geometry.computeVertexNormals();
        geometry.computeTangents();

        console.log( geometry );
          
        material = new THREE.ShaderMaterial({

          uniforms:       uniforms,
          vertexShader:   shaders.vertexShaders.bifrost,
          fragmentShader: shaders.fragmentShaders.bifrost,
          side: THREE.DoubleSide,
          //transparent: true

        });
       
        mesh = new THREE.Mesh( geometry, material );
        mesh.position.x = Math.random();
        mesh.position.y = Math.random();
        mesh.position.z = Math.random();
        scene.add( mesh );

       
        renderer = new THREE.WebGLRenderer();
        renderer.setSize( window.innerWidth, window.innerHeight );

        document.body.appendChild( renderer.domElement );
        stats = new Stats();
        stats.domElement.style.position = "absolute";
        stats.domElement.style.left = "0px";
        stats.domElement.style.bottom = "0px";
        stats.domElement.style.zIndex = "999";
        document.body.appendChild( stats.domElement );

        
        // Making sure our renderer is always the right size
        window.addEventListener( 'resize', onWindowResize , false );
   


      }

      function animate(){

        //mesh.rotation.y += .007 //* Math.sin((i +3)* 20.);
        //mesh.rotation.x += .0059 //* Math.sin((i +3)* 20.);
        //mesh.rotation.z += .0063 //* Math.sin((i +3)* 20.);

        mesh.updateMatrixWorld();
        mesh.material.uniforms.iModelMat.value.getInverse( mesh.matrixWorld );
        /*for( var i = 0; i < meshes.length; i++ ){
          meshes[i].rotation.y += .01 * Math.sin((i +3)* 20.);
          meshes[i].rotation.x += .01 * Math.sin((i +9.62) * 30.);
          meshes[i].rotation.z += .01 * Math.sin( (i +102.) * 40.);
        }*/
        requestAnimationFrame( animate );
        stats.update();
        controls.update();
        renderer.render( scene , camera );
      }



      // Resets the renderer to be the proper size
      function onWindowResize(){

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();


        renderer.setSize( window.innerWidth, window.innerHeight );
       
        var dpr = devicePixelRatio || 1;

        //camUniforms.SS.value.x = window.innerWidth * dpr;
        //camUniforms.SS.value.y = window.innerHeight * dpr;


      }



    </script>

  </body>
</html>
